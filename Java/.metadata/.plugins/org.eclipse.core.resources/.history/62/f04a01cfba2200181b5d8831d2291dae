/**
 * <p><b>La classe Graphe représente le graphe orienté engendré par les résultats des matchs d'une instance de Condorcet.</b><br>
 * Elle est définie par:
 * <ul>
 * 	<li>Le nombre de noeuds du graphe.</li>
 * 	<li>La matrice d'adjancence du graphe.</li>
 * 	<li>
 * </ul>
 * </p><br>
 * @author julien
 */
public class Graphe {
	
	/**
	 * Nombre de noeuds du graphe. Ce nombre n'est pas modifiable.
	 */
	private int noeuds;
	
	/**
	 * Représente la matrice d'adjacence du graphe orienté: si matrice[0][1] = 1 alors 1 pointe vers 0 sinon si matrice[0][1] = 0.<br>
	 * Cette matrice n'est pas modifiable.
	 */
	private int[][] matrice;
	
	/**
	 * Constructeur de Graphe
	 * @param nbAlternatives
	 * 					Le nombre d'Alternatives de l'élection que le graphe doit résoudre
	 * @param compteur
	 * 					Le compteur des résultats des matchs sur toutes les voix de l'élection
	 * @see Condorcet
	 */
	public Graphe(int nbAlternatives, int[][] compteur) {
		this.noeuds = nbAlternatives;
		generationMatrice(compteur);
	}
	
	/**
	 * <b>Génère la matrice.</b><br>
	 * La méthode compare si pour chaque alternative i et j avec i != j, i a gagné plus de match par rapport à j.
	 * Lorsque c'est le cas on met un dans la matrice dans la case matrice[j][i].
	 * Si ils ont gagné autant de match on laisse à zéro.<br>
	 * @param compteur
	 * 				Le compteur de matchs passé au constructeur.
	 * @see Graphe#Graphe(int, int[][])
	 */
	public void generationMatrice(int [][] compteur) {
		this.matrice = new int[noeuds][noeuds];
		for (int i = 0; i < noeuds; i++) {
			for (int j = i + 1; j < noeuds; j++) {
				if(compteur[i][j] > compteur[j][i]) {
					matrice[i][j] = 1;
				}
				else if (compteur[i][j] < compteur[j][i]) {
					matrice[j][i] = 1;
				}
			}
		}
	}
	
	/**
	 * Lecture de la matrice.<br>
	 * @see Graphe#matrice
	 */
	public void lectureMatrice() {
		for (int i = 0; i < noeuds; i++) {
			for (int j = 0; j < noeuds; j++) {
				System.out.print(Integer.toString(matrice[i][j]) + " ");
			}
			System.out.print("\n");
		} 
	}
}
