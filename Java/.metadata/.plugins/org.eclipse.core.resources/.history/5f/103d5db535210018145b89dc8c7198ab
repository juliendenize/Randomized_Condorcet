/**
 * 
 * @author julien
 * <p><b>La classe VoixAleatoire représente la voix généré aléatoirement avec un idVotant pour la rendre unique.</b><br>
 * Elle est définie par:
 * <ul>
 * 	<li>L'ID du votant représenté par la voix.</li>
 * 	<li>Le nombre d'alternatives du vote.</li>
 * 	<li>Le rang des alternatives.</li>
 * </ul>
 * </p>
 */
public class VoixAleatoire {
	
	/**
	 * L'ID du votant représenté par la voix. Cet ID n'est pas modifiable.
	 */
	private int idVotant;
	
	/**
	 * Le nombre d'alternatives du vote. Ce nombre n'est pas modifiable.
	 */
	private int nbAlternatives;
	
	/**
	 * Classement des alternatives. Ce classement n'est pas modifiable.<br>
	 * rangAlternatives[i] donne le rang de l'alternative i selon le classement du votant.<br>
	 * 
	 * @see Voix#rangAlternative
	 */
	private int[] rangAlternatives;
	
	/**
	 * Constructeur VoixAleatoire.
	 * <p>
	 * 	A la construction d'un objet Voix, l'idVotant et nbAlternatives sont fixées.<br>
	 * 	rangAlternatives est  dans la méthode {@link VoixAleatoire#generationRang()}.
	 * </p><br>
	 * @param idVotant L'ID du votant.
	 * @param nbAlternatives Le nombre d'alternatives du vote.
	 * @see VoixAleatoire#idVotant
	 * @see VoixAleatoire#nbAlternatives
	 */
	public VoixAleatoire(int idVotant, int nbAlternatives) {
		this.idVotant = idVotant;
		this.nbAlternatives = nbAlternatives;
		generationRang();
	}
	
	/**
	 * Génère le rang de chaque alternative pour remplir le tableau rangAlternative.
	 * ELle créé un tableau pioche de taille (nbAlternatives + 1) avec pioche[i] = i.
	 * Le tableau pioche permet de stocker les rangs qui n'ont pas encore été tirés.
	 * Boucle for (pioche[0] = nbAlternatives; pioche[0] > 0; i++):
	 * <ol>
	 * 	<li>Génère un nombre aléatoire compris dans l'intervalle [0, pioche[0]].</li>
	 * 	<li>On remplit rangAlternatives[pioche[0]-1] suivant le nbAleatoire:
	 * 		<ul>
	 * 			<li>si nbAleatoire = 0: 0 on perd donc le rang représenté par pioche[pioche[0]].</li>
	 * 			<li>si nbAleatoire = pioche[0]: pioche[nbAleatoire].</li>
	 * 			<li>sinon: pioche[nbAleatoire] et pioche[nbAleatoire] = pioche[pioche[0]] afin de garder le rang qui n'a pas été tiré.</li>
	 * 		</ul>
	 * 		Dans le cas où nbAleatoire = 0 comme on décrémente ensuite pioche[0] on perd le rang représenté par pioche[pioche[0]]
	 * 	</li>
	 * </ol>
	 * <br>
	 *  A la fin de la méthode le classement est bien réalisé même si les nombres ne sont pas nécessairement consécutifs ils sont uniques et cela n'entraine donc pas de problèmes pour utiliser ensuite {@link Condorcet#parcoursVoix()} <br>
	 *  @see VoixAleatoire#rangAlternatives
	 *  @see Condorcet#parcoursVoix()
	 */
	public void generationRang() {
		this.rangAlternatives = new int[nbAlternatives];
		int nbAleatoire;
		int[] pioche = new int[nbAlternatives + 1];
		
		for (int i = 1; i < nbAlternatives + 1; i++) {
			pioche[i] = i;
		}
		
		for (pioche[0] = nbAlternatives; pioche[0] > 0; pioche[0]--) {
			nbAleatoire = (int)(Math.random() * (pioche[0] + 1));
			if (nbAleatoire == 0) {
				rangAlternatives[pioche[0] - 1] = 0;
			}
			else if (nbAleatoire == pioche[0]){
				rangAlternatives[pioche[0] - 1] = pioche[nbAleatoire];
			}
			else {
				rangAlternatives[pioche[0] - 1] = pioche[nbAleatoire];
				pioche[nbAleatoire] = pioche[pioche[0]];
			}
		}
	}
	
	public String toString() {
	 	String str = "Voix du votant " + Integer.toString(idVotant) + " :";
	 	for (int i = 0; i < nbAlternatives; i++) {
	 		str += " " + (i+1) + " rang " + rangAlternatives[i] + " ;"; 
	 	}
	 	return str;
	}
}
